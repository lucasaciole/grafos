{% extends "article_template.html" %}
{% block content %}
<div class="container">
    <div class="row text-center">
        <div class="col-lg-12">
            <h1>T2</h1>
            <p class="lead">Snakes and Ladders</p>
        </div>
    </div>
    <div class="row">
        <div class="col-lg-12">
            <h1 class="text-center">O jogo</h1>
            <p>Snakes and Ladders é um famoso jogo de tabuleiro em que a cada rodada um jogador joga uma moeda não viciada e avança 1 casa se obtiver cara ou avança 2 casas se obtiver coroa. Se o jogador para no pé da escada, então ele imediatamente sobe para o topo da escada. Se o jogador cai na boca de um cobra então ele imediatamente escorrega para o rabo. O jogador sempre inicia no quadrado de número 1. O jogo termina quando ele atinge o quadrado de número 36.
            </p>
            <p> O objetivo deste trabalho é utilizar o conhecimento de Cadeias de Markov para analisar o jogo.</p>
            <img class="center-block" src="/static/img/snakesladders.jpg" placeholder="tabuleiro do snakes and ladders" width="600px"></img>
            <p class="text-center"><b>Imagem 1.1</b> Tabuleiro de exemplo utilizado pelo projeto.</p>
            <br/>
            <h1 class="text-center">Cadeias de Markov</h1>
            <p> Uma cadeia de Markov é um processo aleatório em que a probabilidade de se visitar um estado
                s num tempo t depende apenas do estado s’ visitado no tempo t – 1</p>            
            <p> Ela pode ser definida por uma matriz de probabilidades de transição de estados P, definida como &Delta;<sup>−1</sup> x A, onde A é a matriz de adjacência de um grafo G=(V,E) e &Delta;<sup>−1</sup> é uma matriz que tem como elemento e(i,i) = 1/grau(vi) e todo o resto da matriz igual a zero</p>
            <img class="center-block" src="/static/img/matriz_def.png" placeholder="definição da mpte" width="600px" />
            <p class="text-center"><b>Imagem 1.2</b> Definição da Matriz de Probabilidade de Transição de Estados.</p>
            <p> Uma Cadeia de Markov Homogênea (CMH) pode ser definida pela tripla:
            CMH=(S ,P,w⃗<sup>(0)</sup>) onde:<br/>
            S={s1,s2,s3,... ,sn} é um conjunto finito de n estados;<br/>
            P=&Delta;<sup>−1</sup> x A é a matriz de probabilidades de transição (função de transição) e;<br/>
            w⃗<sup>(0)</sup> é um vetor de probabilidades iniciais para cada estado (distrib. de probabilidades inicial) de modo que ∑i wi=1</p> Exemplo: w⃗<sup>(0)</sup> = [1,0,0,0,... ,0]
            <p> Para o nosso tabuleiro, foi encontrada a seguinte Matriz de Probabilidade de Transição de Estados:</p>
            <img class="center-block" src="/static/img/matriz_snakes_and_ladders.png" placeholder="mpte do snakes and ladders" width="600px"></img>
            <p class="text-center"><b>Imagem 1.3</b>  Matriz de Probabilidade de Transição de Estados do tabuleiro utilizado pelo projeto.</p>
            <p> Através dessa matriz, podemos construir um diagrama de estados que representa as possibilidades do jogo:</p>
            <img class="center-block" src="/static/img/snakes_and_ladders_diagram.png" placeholder="diagrama do snakes and ladders" width="600px"></img>
            <p class="text-center"><b>Imagem 1.4</b>  Diagrama de Estados do tabuleiro utilizado pelo projeto.</p>
            <p>O objetivo deste projeto é desenvolver um script em Python para calcular a distribuição estacionária da cadeia de Markov.</p>
            <p>Seja P a matriz de transição de uma CMH irredutível e aperiódica. Então, a distribuição estácionária
            existe e é única, sendo independente de w⃗<sup>(0)</sup>.</p>
            <p>Em outras palavras, isso significa que para k →∞ , w⃗<sup>(k)</sup> converge para um valor fixo chamado de distribuição estacionária da cadeia de Markov.</p>
            <p>A distribuição estacionária de uma CMH fornece a probabilidade de estar em cada um dos estados no longo prazo.</p>
            <p>Um meio de calcular a distribuição estacinoária é utilizando o <i>Power Method</i>, que faz o seguinte cálculo:</p>
            <p class="lead text-center">w⃗<sup>(k)</sup> = w⃗<sup>(0)</sup> x P<sup>k</sup>.</p>
        </div>
    </div>
    <div class="row">
        <div class="col-lg-6 col-lg-offset-3">
            <!-- HTML generated using hilite.me -->
            <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                <pre style="margin: 0; line-height: 125%">
<span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">power_method</span>(M, w0, k):
    result <span style="color: #333333">=</span> copy<span style="color: #333333">.</span>deepcopy(M)
    result <span style="color: #333333">=</span> multiply_matrix([w0], result)
    <span style="color: #008800; font-weight: bold">for</span> _ <span style="color: #000000; font-weight: bold">in</span> <span style="color: #007020">range</span>(k): result <span style="color: #333333">=</span> multiply_matrix(result, M)
    <span style="color: #008800; font-weight: bold">return</span> result
                </pre>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-lg-12">
        <p class="text-center"><b>Código 1.1</b> Power Method implementado em Python.</p>
        </div>
    </div>
    <div class="row">
        <div class="col-lg-12">
        <p class="text-center"><b>Código 1.1</b> Power Method implementado em Python.</p>
        </div>
    </div>
</div>
{% endblock %}